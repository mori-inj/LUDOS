# AT-BIOS

## INT(0x10): 비디오 관련  
### 비디오 모드 설정  
* AH: 0x00  
* AL: 모드(자주 사용되는 화면 모드만 설명)  
    * 0x03: 16색 텍스트, 80x25  
    * 0x12: VGA 그래픽스, 640 x480x4bit 칼라  
    * 0x13: VGA 그래픽스, 320 x200x8bit 칼라, Packed Pixel  
    * 0x6a: 확장 VGA 그래픽스, 800 x600x4bit 칼라  
* 반환값: 없음  
  
### 커서 모양 설정  
* AH: 0x01  
* CH: 시작 라인  
* CL: 종료 라인  
    * CH < CL라면 1개의 부분으로부터 되는 보통 커서  
    * CH > CL라면 2개의 부분으로부터 되는 커서  
    * CH == 0x20이면 커서는 표시되지 않음  
* 반환값: 없음  
  
### 커서 위치 지정  
* AH: 0x02  
* BH: 0(페이지 번호)  
* DL: x 좌표  
* DH: y 좌표  
* 반환값: 없음  
  
### 점 출력  
굳이 이 함수를 이용하지 않고 바로 Video 메모리를 이용할 수도 있음  
* AH: 0x0c  
* AL: 색상 코드(0 ~ 15)  
* CX: x좌표  
* DX: y좌표  
* 반환값: 없음  
  
### 한 문자 출력  
* AH: 0x0e  
* AL: 문자 코드  
* BH: 0(페이지 번호)  
* BL: 문자의 색  
* 반환값: 없음  
주의) beep(0x07), 백 스페이스(0x08), CR(0x0d), LF(0x0a)는 제어 코드로서 인식  
  
### 색상 코드를 대응되는 팔레트에 저장  
16색 모드일 때만 사용 가능  
* AX: 0x1000  
* BL: 색상 코드(0 ~ 15)  
* BH: 팔레트 코드(0 ~ 63)  
주의) EGA 그래픽 카드와의 호환성을 유지하기 위해서 사용. 잘못 사용하면 상당히 복잡해지므로 기본값 그대로 두고 사용.    
  
### 팔레트 설정  
* AX: 0x1010  
* BX: 팔레트 번호(0 ~ 255)  
* DH: Red(0 ~ 63)  
* CH: Green(0 ~ 63)  
* CL: Blue(0 ~ 63)  
* 반환값: 없음  
  
### 문자열 출력  
* AH: 0x13  
* AL: 옵션  
    * 0x00: 문자열의 속성을 BL 레지스터로 지정하고 커서는 이동시키지 않음  
    * 0x01: 문자열의 속성을 BL 레지스터로 지정하고 커서를 이동  
    * 0x02: 문자열을 출력하고 커서는 이동시키지 않음   
    * 0x03: 문자열을 출력하고 커서를 이동  
      실제 데이터는 메모리에 [문자 코드] [칼라 코드] [문자 코드] [칼라 코드]와 같이 저장  
* BH: 0(페이지 번호)  
* BL: 칼라 코드(AL 레지스터의 값이 0x01, 0x02일 경우에만 적용)  
* CX: 문자열의 길이  
* DL: x좌표  
* DH: y좌표  
* ES:BP = 출력할 문자열이 있는 곳의 주소  
* 반환값: 없음  
  
### 제일 간단하게 사용할 수 있는 화면모드인 0x13의 사용법  
0x13번 화면모드는 그다지 해상도가 좋지는 않지만  
Packed Pixel 모드이기 때문에 프로그래밍 하기가 편합니다.  
우선 화면 모드를 변경하고 팔레트를 설정합니다.  
이 모드는 Video Ram의 0xa0000 ~ 0xafff의 64KB에 위치하게 됩니다.  
정확히 말하면 320 x 200 = 64000이 되므로 62.5 KB라고 해야겠지만,  
VRAM는 0xa0000 ~ 0xaffff의 64 KB입니다.  
엄밀하게 말하면(자), 320 x200=64000이므로, 62.5 KB가 됩니다.  
이 모드에서는 점 하나가 1바이트에 해당되기때문에 읽고 쓰기도 아주 간단합니다.  
  
  
## INT(0x11): H/W 구성 확인  
컴퓨터에 설치된 H/W의 리스트를 확인  
* 입력값: 없음  
* 반환값:  AH == 장치 코드  
(사용하는 사람이 거의 없기때문에 정확한 내용은 생략)  
  
  
## INT(0x12): 시스템에 있는 메모리의 크기를 조사  
시스템에 있는 메모리의 크기를 조사  
* 입력값: 없음  
* 반환값: AX == 메모리의 크기(KB 단위)  

## INT(0x13): 디스크 관련 함수  
* AH
    * 0x00: 디스크 시스템 리셋  
    * 0x01: GET STATUS OF LAST OPERATION  
    * 0x02: 디스크 읽기  
    * 0x03: 디스크 쓰기  
    * 0x04: Verify(디스크 섹터 검사)  
* AL: 처리할 섹터 수(연속된 섹터 처리 가능)  
* CH: 실린더 번호 & 0xFF  
* CL: 섹터 번호(bit 0-5) | (실린더 번호 & 0x300) >> 2  
* DH: 헤드 번호  
* DL: 드라이브 번호(0x00 ~ 0x7f：FDD, 0x80 ~ 0xff：HDD)  
* ES:BX = 버퍼 어드레스(검사 or 찾기 시 참조 안 함)  
* 반환값:  
    * FLAGS.CF == 0 : 에러 없음, AH == 0  
    * FLAGS.CF == 1 : 에러 발생, AH에 에러 코드가 저장  
* 에러 코드 (FDD, HDD 모두 발생 가능한 에러 코드):  
    * 0x01: 디스크 Parameter가 잘못 전달  
    * 0x02: Address Mark가 발견되지 않음  
    * 0x04: 섹터를 찾지 못함  
    * 0x09: DMA 오버플로우  
    * 0x10: 데이터 에러  
    * 0x20: 콘트롤러 이상  
    * 0x40: 탐색 실패(Seek Failure)  
    * 0x80: 타임 아웃  
* 에러 코드 (FDD일 경우의 에러코드)  
    * 0x03: 쓰기 금지된 디스크에 쓰기를 시도  
    * 0x06: 디스크를 찾지 못함  
    * 0x08: DMA 오버플로우  
* 에러 코드 (HDD일 경우의 에러코드)  
    * 0x05: 리셋 실패  
    * 0x07: Parameter 테이블이 정확하지 않음  
    * 0x0a: 섹터 Flag이 잘못되었음  
    * 0x11: ECC 데이터 에러  
    * 0xaa: 드라이브가 아직 준비되지 않음
    * 0xbb: 미정의 에러
    * 0xcc: 쓰기 에러  
    * 0xe0: 상태(Status) 에러  
  
  
  
  
1차 출처: http://osguru.net/index.php/AT-BIOS  
2차 출처: http://m.blog.daum.net/baiil/3382975  
other references:  
http://www.ctyme.com/intr/int.htm  // <- 여기가 제일 나은 듯  
https://en.wikipedia.org/wiki/BIOS_interrupt_call  
https://en.wikipedia.org/wiki/INT_%28x86_instruction%29  
