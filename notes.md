#LUDOS

##Day1

* LUDOS_0.img: 디스크 이미지 파일을 바이너리 에디터를 이용해 일일이 기록. 편집이 불편하고 패딩을 위해 존재하는 0x00을 일일이 입력해야 한다는 불편함이 존재.  
* LUDOS_1.nas: LUDOS_0.img를 DB 명령어를 사용해 어셈블리 코드로 생성하고, 0x00를 RESB를 사용해 단축.  
* LUDOS_2.nas: LUDOS_1.nas에서 DB명령어로 작성된 코드 중, 앞부분의 FAT포맷을 위한 설정 부분과 화면에 출력할 메세지를 출력하는 부분을 좀 더 의미가 명확한 어셈블리 코드로 작성. [FAT설정 / 프로그램 본체 / 메세지 출력 / 부트섹터 이외의 부분]으로 구성. 
    * asm.bat: nask 어셈블러를 이용해 nas 파일을 img파일로 생성(img파일도 bin파일과 본질적으로 동일하지만 디스켓에 구울 수 있냐 여부가 다른듯)
    * run.bat: qemu 에뮬레이터를 이용해 img파일을 부팅
    * install.bat: A드라이브(디스켓)에 구움(안 씀).

###부트 섹터
플로피디스크에서 1섹터 = 512바이트.  
1440KB = 1474560B = 512 * 2880이므로 2880개의 섹터로 구성.  
이들 중 첫번째 섹터가 부트 섹터.  
부팅 시에 부트 섹터의 맨 끝 2바이트가 55 AA 인지 읽는다.  
(55 AA가 아니면 부팅할 수 없는 프로그램으로 판단)  

###IPL
부트 섹터 하나만으로는 당연하게도 OS를 다 담을 수 없다.  
부트 섹터에는 그 뒤에 나올 OS의 나머지 부분들을 읽게끔 하는 프로그램을 써 두는데 이를 Initial Program Loader(IPL)이라 한다.  
cf. 부트 섹터의 이름은 반드시 8바이트여야 한다.  

###어셈블리 정리
* ;: 주석
* DB: Data Byte의 약자로 파일에 1바이트 크기의 내용을 직접 쓴다. 대소문자 구분x  
* DW: Data Word의 약자로 2바이트(16비트)크기의 내용을 직접 쓴다.  
* DD: Data Double-word의 약자로 4바이트(32비트)크기의 내용을 직접 쓴다.  
* RESB: Reserve Byte의 약자로 지정한 크기만큼 띄어둔다는 의미. NASK에선 자동으로 0으로 초기화.  
* $: 특정 행이 선두로부터 몇 바이트인지 알려줌. 현재부터 0x1fe번지까지를 0으로 채우고 싶은 경우 RESB 0x1fe-$ 와 같은 형태로 사용가능.  

###NASK
NASM이라는 어셈블러(어셈블리 코드를 기계어로 바꿔줌)를 개량한 어셈블러.  
  
  
  
  
  
  
##Day2

[FAT설정 / 프로그램 본체 / 메세지 출력 / 부트섹터 이외의 부분]  
* LUDOS_3.nas: LUDOS_2.nas에서 FAT설정과 메세지 출력 부분을 명확히 했다면, 3.nas에서는 프로그램 본체 부분을 좀 더 의미가 잘 드러나는 어셈블리 코드로 작성. JMP명령어로 프로그램의 흐름은 프로그램 본체( entry: )로 바로 이동하고 FAT설정 부분은 그냥 그 자리에 존재함으로써 설정을 담당하는 것으로 추정.  
    * ipl.nas: LUDOS_3.nas에서 초기 512바이트(IPL)를 제외한 뒷부분을 제거. (이 뒷부분을 어떻게 만드는지 모르겠음...ㅂㄷㅂㄷ)
    * asm.bat: ipl.nas를 ipl.bin으로 바꿈. ipl.lst(objdump한 결과와 유사)를 추가적으로 생성함.
    * makeimg.bat: ipl.bin을 토대로 img파일(1440KB) 생성. edimg.exe라는 프로그램을 사용하며, 이 프로그램이 제거된 뒷 부분을 추가해주는 것으로 추정.
* Makefile: Windows에서도 make.exe(GNU에서 만듦)를 이용해 Makefile을 사용 가능. 기존 배치파일들(asm, run, install, makeimg 등)을 Makefile 하나로 관리할 수 있으며, 파일들의 일괄적인 삭제도 가능. (프로그램 이름을 argument형태로 전달 하고 싶었지만 아직 Makefile의 변수 사용에 익숙하지 않아 일단 넘어감.)
  
  
  
###레지스터 정리(16비트 기준) 

####범용 레지스터  
* AX: accumulator  
* CX: counter  
* DX: data  
* BX: base  
* SP: stack pointer  
* BP: base pointer  
* SI: source index  
* DI: destination index  

####세그먼트 레지스터  
* ES: extra  
* CS: code  
* SS: stack  
* DS: data  
* FS: extra2  
* GS: extra3  
  
  

###어셈블리 정리
* ORG: 기계어가 실행될 PC상의 메모리 위치를 지정.$의 의미도 ORG를 기준으로 재정의. ([0x7c00으로 설정하는 이유](https://github.com/mori-inj/LUDOS/blob/master/AT-MemoryMap.md))  
* MOV: 특정 레지스터나 메모리에 값을 쓰는 명령어. movl, movq 등과 달리 MOV BYTE, MOV WORD 형태로 쓰이니 주의. 메모리의 주소값을 지정할 수 있는 레지스터는 BX, BP, SI, DI 뿐.  
* INT: 인터럽트. (바이오스)함수를 호출하는 데에 사용. [사용 가능한 함수 목록](https://github.com/mori-inj/LUDOS/blob/master/AT-BIOS.md)  
* HLT: halt. 아무 것도 하지 않고 CPU를 대기상태에 두게 하는 명령어. (몹시 맘에 듦)  




###BIOS(Basic Input Output System)  
원래는 OS개발자를 위한 함수 모음. INT를 이용해 호출하며 INT 뒤의 숫자로 호출될 함수를 결정. 0x10 함수의 경우 [비디오카드 제어](https://github.com/mori-inj/LUDOS/blob/master/AT-BIOS.md#한-문자-출력) 관련. 

  
  
  
  
  
  
##Day3

* ipl_a.nas: 이제 본격적으로 ipl을 만들고 512바이트가 뒤의 내용을 읽어오게끔 하는 작업(부트로더, Day2에서 edimg.exe가 해주는 것으로 추정되던 작업)을 하기 시작. (디스크에서 내용을 읽어오는 법: [BIOS INT(0x13)](https://github.com/mori-inj/LUDOS/blob/master/AT-BIOS.md#int0x13--디스크-관련-함수)) ES:BX를 묶어서 버퍼 어드레스로 사용하는데, 읽어온 데이터를 저장할 메모리 상의 공간을 지정. 지정한 주소로부터 한 섹터의 크기인 512바이트까지 디스크로부터 읽어온 데이터가 write됨. 레지스터가 16비트(2바이트)라 2개를 묶어서 총 4바이트를 주소를 지정하는데 쓰...ㄹ 것 같지만 그렇지 않고, ES * 16 + BX 같은 변태 같은 꼴로 사용함. 따라서 접근 가능한 메모리는 약 1메가 바이트 남짓(1114095==0x10FFEF Byte). 당시에는 32비트를 고려하지 않았고, 1메가로도 충분할 것으로 생각했겠지... 다른 어셈블리 인스트럭션에서도 암묵적으로 [DS:]가 생략된 것으로 볼 수 있고, 명시적으로 DS를 쓰지 않는 경우, DS를 0으로 설정해줘야 함. 2번 섹터를 읽음에 주의. 1번 섹터는 부트로더 자기 자신이므로 굳이 읽을 필요 없음.  
* ipl_b.nas: 디스켓이 제대로 읽어오지 못할 경우 드라이브 리셋 후 다시 읽어오기 시도. 최대 5번.  
* ipl_c.nas: 18섹터까지 읽기 시도. 코드는 루프를 사용해서 한 섹터씩 읽어 오고 있지만 AL을 17(2부터 18)로 정해도 되지만, 연속된 섹터를 루프 없이 한번에 읽을 경우 제한 조건이 붙기 때문에 루프로 읽는 것을 연습.  
* ipl_d.nas: 10실린더까지 읽기 시도.  
* Makefile: 변수를 사용하는 형태로 좀 더 깔끔하게 작성. 생성해내는 파일의 이름을 변수로 설정하는 방법은 여전히 모르겠음...  


###디스크 구조(소위 말하는 디스켓)
* 실린더: 디스크를 구성하는 동심원. 바깥쪽부터 안쪽까지 0에서 79, 총 80개가 존재.  
* 헤드: 디스크의 앞/뒤 구분. 0과 1로 표기.  
* 섹터: 원주를 따라 하나의 실린더를 18등분 한 조각(개당 20도의 중심각을 갖겠군). 1에서 18로 표기.  
* Cx-Hy-Sz의 형태로 표기함. (ex. C0-H0-S1) 80 * 2 * 18 * 512B = 1474560B = 1440KB. 어떤 섹터의 다음 섹터를 찾을땐, 진법처럼 섹터가 18을 넘으면 헤드가 증가, 헤드가 1을 넘으면 실린더가 증가하는 식.  

###어셈블리 정리
* EQU: C언어에서 #define과 같음. (ex. CYLS EQU 10 은 #define CYLS 10 과 동일.) EQU는 알다시피 equal의 약자.  

