#Video Graphic Array  
(by K )
* 640x480이라는 해상도를 가리 키기도한다
* 비디오 카드 전반를 VGA로 쓸 때는 Video Graphic Adapter, Video Graphic Acceralator의 의미로 해석하는 것이 보통
* 여기에서는 그 어느쪽에 대해서도 관심이 아니라 AT 호환 공수에서 BIOS를 전혀 사용하지 640x480x16 색 그리기를하는 데 필요한 기술 자료를 정리하고 싶다
     * 가장 손쉬운 방법은 BIOS를 사용하여 320x200x256 색으로 전환 팔레트를 설정하고, 나머지는 VRAM을 직접 액세스하는 방법이다. → (AT) BIOS
     * 이 해상도에 질리면 다음은 VESA의 선형 액세스로 진행 것을 추천한다 (창 액세스 창 전환이 귀찮은).
     * 하지만 VESA의 선형 액세스는 32bit 모드를 다룰 필요가 있고, VESA 사용할 수없는 카드도 그저있다. 이 경우 거의 모든 비디오 카드가 지원하는 VGA를 이용하고 싶을 수도있을 것이다. 색상은 320x200x256 색에 비해 상당히 적어 지지만 (16 색) 해상도가 640x480이되는 것은 고마운 것이다.
* 기술은 실기에서 확인되지 않은 정보도 포함하기 때문에 틀릴 수도있을 수 있습니다. 의견에 유용한 지적이되고 있으므로, 그 쪽도 꼭 확인.

##VGA 레지스터  

###CRT 컨트롤러  
* 0x03d4에 16bit 액세스 기록
bit0-7이 레지스터 번호
bit8-15 데이터
* 0x03d4과 0x03d5 바이트 액세스하는 방법도있다
   * 이 경우 우선 0x03d4 레지스터 번호를 표시하고 0x03d5에 데이터를 기록하거나 혹은 0x03d5을 선도하고 레지스터 데이터를 읽어 들인다.
* 흑백 디스플레이의 경우 I / O 포트가 0x03b4,0x03b5된다
   * 어느 쪽인지 모를 때는 I / O 포트 0x03cc을 선도하고 bit0을 보면 알 수있다. 0이라면 0x03b4,1라면 0x03d4이다.
* [0x00] Horizo​​ntal Total (가로 총 문자 수)
   * bit0-7 : 수평 주사 기간 내의 문자 수
* [0x01] Horizo​​ntal Display Enable End (수평 표시 문자 수)
   * bit0-7 : 수평 주사 기간의 표시 문자 수 - 1
* [0x02] Start Horizo​​ntal Blanking (수평 숨기기 시작 문자 위치)
   * bit0-7 : 수평 숨기기를 시작하는 문자 위치
* [0x03] End Horizo​​ntal Blanking (수평 숨기기 종료 문자 위치)
   * bit0-4 : 수평 숨기기를 종료하는 문자 위치
   * bit5-6 : 수평 표시 스큐
   * bit7 : 예약
* [0x04] Start Horizo​​ntal Retrace (수평 귀선 시작 문자 위치)
   * bit0-7 : 수평 귀선을 시작하는 문자 위치
* [0x05] End Horizo​​ntal Retrace (수평 귀선 종료 문자 위치)
   * bit0-4 : 수평 숨기기를 종료하는 문자 위치
   * bit5-6 : 수평 귀선 스큐
   * bit7 : 수평 숨기기 종료 위치의 비트 5
* [0x06] Vertical Total (수직 라인 수)
   * bit0-7 :( 수직 주사선 -2)의 하위 8 비트
* [0x07] Overflow (각종 상위 비트)
   * bit0 : Vertical Total 비트 8
   * bit1 : Vertical Display Enable End 비트 8
   * bit2 : Vertical Retrace Start 비트 8
   * bit3 : Start Vertical Blanking 비트 8
   * bit4 : Line Compare 비트 8
   * bit5 : Vertical Total 비트 9
   * bit6 : Vertical Display Enable End 비트 9
   * bit7 : Vertical Retrace Start 비트 9
* [0x08] Preset Row Scan (프리셋 행 주사)
   * bit0-4 : 수직 스크롤의 라인 수 (텍스트 모드)
   * bit5-6 : 수평 스크롤의 비트 수 (바이트 단위)
   * bit7 : 예약
* [0x09] Maximum Scan Line (최대 주사 수)
   * bit0-4 : 1 캐릭터 라인 수 -1
   * bit5 : Start Vertical Blanking 비트 9
   * bit6 : Line Compare 비트 9
   * bit7 : 200 라인 모드 이중 표시 지정
* [0x0a] Cursor Start (커서 서두 위치)
   * bit0-4 : 커서 표시 라인 -1
   * bit5 : 커서 숨기기 플래그
   * bit6-7 : 예약
* [0x0b] Cursor End (커서 종료 라인)
   * bit0-4 : 커서 끝 라인 -1
   * bit5-6 : 커서 스큐
   * bit7 : 예약
* [0x0c] Start Address High (VRAM보기 시작 주소 상위)
   * bit0-7 :보기 시작 주소 상위 8 비트
* [0x0d] Start Address Low (VRAM보기 시작 주소 이전)
   * bit0-7 :보기 시작 주소 하위 8 비트
* [0x0e] Cursor Location High (커서 위치 상위)
   * bit0-7 : 커서 위치의 상위 8 비트
* [0x0f] Cursor Location Low (커서 위치 이전)
   * bit0-7 : 커서 위치의 하위 8 비트
* [0x10] Vertical Retrace Start (수직 귀선 시작 라인 위치)
   * bit0-7 : 수직 귀선을 시작할 위치
* [0x11] Vertical Retrace End (수직 귀선 종료 라인 위치)
   * bit0-3 : 수직 귀선을 종료하는 라인 위치
   * bit4 : 수직 귀선 인터럽트시에 통보 (0시)
   * bit5 : 수직 귀선 인터럽트의 허가 (0시)
   * bit6 : 수평 주파수의 선택
   * bit7 : [0x00] ~ [0x07] 레지스터의 쓰기 방지 (1에서 기록되지)
* [0x12] Vertical Display Enable End (표시 라인 수)
   * bit0-7 : 수직 표시를 종료하는 라인 위치의 하위 8 비트
* [0x13] Offset (VRAM에 1 라인 폭)
   * bit0-7 : 1 라인 당 폭 (그래픽의 경우는 워드 단위)
* [0x14] Under Line Location (밑줄 표시 줄 위치)
   * bit0-4 : 밑줄 표시 줄 (텍스트 모드)
   * bit5 : 시계 4 분주 (1시)
   * bit6 : 16 비트 / 32 비트 주소 전환 (1에서 32 비트)
   * bit7 : 예약
* [0x15] Start Vertical Blanking (수직 숨기기 시작 라인 위치)
   * bit0-7 : 수직 숨기기를 시작하는 라인 위치의 하위 8 비트
* [0x16] End Vertical Blanking (수직 숨기기 종료 라인 위치)
   * bit0-7 : 수직 숨기기를 종료하는 라인 위치의 하위 8 비트
* [0x17] Mode Control (모드 설정)
   * bit0 : 1로하면 인터레이스 표시
   * bit1 : 1로하면 수직 라인 주소 사용
   * bit2 : 1로하면 세로 폭 2 배
   * bit3 : 1로하면 클럭 2 분주
   * bit4 : 예약
   * bit5 : 주소 바꿈 지정
   * bit6 : 8 비트 / 16 비트 주소 전환 (1에서 16 비트)
   * bit7 : 1로하면 수직 수평 귀선 허가
* [0x18] Line Compare (화면 분할 선 위치)
   * bit0-7 : 화면을 분할하는 선 위치의 하위 8 비트
* 0x19 이후의 레지스터는 리저브

###속성 컨트롤러  
* 0x03c0에 8bit 액세스 기록 (주소 포트시)
   * bit0-4이 레지스터 번호
   * bit5-7 000
   * 기록 완료와 동시에 데이터 포트로 바뀐다
* 0x03c0에 8bit 액세스 기록 (데이터 포트시)
   * bit0-7이 레지스터 데이터
* 0x03c0에 8bit 액세스에서 0x20 기록 (정상 모드 복귀 직후)
   * 이제 속성 컨트롤러는 완전히 정상 모드로
* 0x03c1에 8bit 액세스로드 (데이터 포트시)
   * bit0-7이 레지스터 데이터
   * 일부 문서에서는 리드도 0x03c0쪽으로 읽고 설명하고있다. 어느 쪽이 옳은지 아직 테스트하지 않기 때문에 모르는 (죄송합니다).
* 구체적인 접근 방법
   * 다음 작업 중 인터럽트 등을 받아들이지 않게한다. 시간적인 사이가 교련 다른 I / O에 방문하는 것만으로도,이라고 단순히 이상 해지는 비디오 칩이 많다.
   * 0x03da을 하늘 읽기 (0x03ba의 경우도있다 - 어느 쪽이 될까는 I / O 포트 0x03cc을 선도하고 bit0 확인 - 참고 : VGA 컨트롤러)
      * 하늘 읽기 값은 다른 용도로 이용해도 좋지만, 우선 속성 컨트롤러를 사용하는 것만한다면 필요하지 않으므로 버린다.
   * 다음을 원하는만큼 다하겠습니다.
      * 0x03c0에 등록 번호를 기입 (0x00~0x14). 그리고 0x03c0 레지스터 데이터를 기록한다.
      * 0x03c0에 등록 번호를 기입 (0x00~0x14). 그리고 0x03c1에서 레지스터 데이터를로드 (읽기도 0x03c0를 사용한다고 적혀있는 자료도 있으므로 여기 좀 자신 없음).
      * (주) 레지스터 번호를 기입 해, 데이터를 쓴다거나 읽거나 할 수있는 것은 한 번 뿐이다. 같은 레지스터에 순차적으로 접근하고자한다면 동일한 레지스터 번호를 다시 기록하게된다.
       * (주) 레지스터 번호를 쓰면 반드시 데이터를 쓰거나 읽는 가지 중 하나를 할 일.
   * 속성 컨트롤러에 접근이 끝나면 또 즉시 0x03da을 하늘 읽을 (0x03ba의 경우도있다 - 위로 동일)
   * 그리고 0x03c0에 0x20을 쓴다.
   * 이제 비디오 칩은 보통 상태로 돌아갑니다.
* [0x00] - [0x0f] Color Palette 0~15 (비디오 DA 컨버터에 전달 컬러 코드)
   * bit0-5 : 비디오 DA 컨버터에 전달 색상 코드 (0부터 63)
   * bit6-7 : 리저브 (기입시에는 0 권장)
* [0x10] Mode Control (표시 모드)
   * bit0 : 그래픽 모드 선택 (0 : 텍스트 1 : 그래픽)
   * bit1 : 흑백 모드 선택 (0 : 컬러 1 : 흑백)
   * bit2 : 그래픽 캐릭터 선택
   * bit3 : 블링크 선택 (0 : 고휘도 1 : 블링크)
   * bit4 : 리저브 (기입시에는 0 권장)
   * bit5 : 레지스터 [0x13] 설정 (0 : 무효, 1 : 유효)
   * bit6 : 팍 크드 픽셀 선택 (0 : 컬러 일반 1 : 팍 크드 픽셀)
   * bit7 : 레지스터 [0x14] 설정 (0 : [0x00] - [0x0f] 유효 [0x14]은 무효, 1 : [0x14] 유효 [0x00] - [0x0f이 비활성화)
* [0x11] Sreen Border Color (테두리 색상)
   * bit0-7 : 테두리 색상
* [0x12] Color Plane Enable (일반 표시 허가)
   * bit0 : 일반 0 표시 허가 (1로 표시)
   * bit1 : 일반 1 표시 허가 (1로 표시)
   * bit2 : 일반 2 표시 허가 (1로 표시)
   * bit3 : 일반 3 표시 허가 (1로 표시)
   * bit4-5 : Input Status 1에 출력하는 일반 번호
   * bit6-7 : 리저브 (기입시에는 0 권장)
* [0x13] Horizo​​ntal Panning (수평 스크롤)
   * bit0-3 : 수평 스크롤 픽셀 수
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x14] Color Select (컬러 코드 상위)
   * bit0-3 : 비디오 DA 컨버터에 전달 컬러 코드의 상위 번호
   * bit4-7 : 리저브 (기입시에는 0 권장)
   * 0x15 이후의 레지스터는 리저브

###VGA 컨트롤러  
* 0x03c2 : 상태 레지스터 (8bit, R)
   * bit0-3 : 예약
   * bit4 : 스위치 지정 (1면 컬러 디스플레이)
   * bit5-6 : 예약
   * bit7 : 수직 인터럽트 발생 중
* 0x03c2 : 스토브 설치 레지스터 (8bit, W)
   * bit0 : I / O 주소 지정
      * 0 : 0x03b4,0x03b5,0x03ba
      * 1 : 0x03d4,0x03d5,0x03da
   * bit1 : 비디오 버퍼 권한 (1 허용)
   * bit2-3 : 클럭 지정 (00 : 640 점, 다른 사람은 알 수 없음)
   * bit4 : 예약
   * bit5 : CGA 페이지 전환 (0 : 낮은 64KB 페이지)
   * bit6 : 수평 귀선의 극성
   * bit7 : 수직 귀선의 극성
* 0x03c3 : VGA 동작 허가 레지스터 (8bit, W)
   * bit0 : VGA 동작 허가 (1 : 동작 허가)
   * bit1-7 : 예약
* 0x03cc : 읽기 용 컨트롤 레지스터 (8bit, R)
   * bit0-5 : 스토브 설치 레지스터와 같은 (위 참조)
   * bit6-7 : 수직 라인 지정 (11라면 480 라인)
* 0x03da : 컬러 상태 레지스터 (8bit, R)
   * 이것은 0x03cc의 bit0가 1 일 때만 유효
   * bit0 : 표시 기간 중 (0 일 때)
   * bit1-2 : 예약
   * bit3 : 수직 帰線 중 (1 때)
   * bit4-7 : 예약
   * 이 레지스터 속성 컨트롤러의 정상 작동에 더미 리드하면 속성 컨트롤러 0x03c0이 주소 포트된다.
   * 이 레지스터 속성 컨트롤러의 데이터 포트 사용 후 더미 리드하면 속성 컨트롤러가 정상 작동으로 돌아갑니다.
* 0x03ba : 흑백 상태 레지스터 (8bit, R)
   * 이것은 0x03cc의 bit0이 0 일때에만 유효
   * bit0 : 표시 기간 중 (0 일 때)
   * bit1-2 : 예약
   * bit3 : 수직 帰線 중 (1 때)
   * bit4-7 : 예약
   * 이 레지스터 속성 컨트롤러의 정상 작동에 더미 리드하면 속성 컨트롤러 0x03c0이 주소 포트된다.
   * 이 레지스터 속성 컨트롤러의 데이터 포트 사용 후 더미 리드하면 속성 컨트롤러가 정상 작동으로 돌아갑니다.

###시퀀서  
* 0x03c4에 16bit 액세스 기록
   * bit0-7이 레지스터 번호
   * bit8-15 데이터
* 0x03c4과 0x03c5 바이트 액세스하는 방법도있다
   * 이 경우 우선 0x03c4 레지스터 번호를 표시하고 0x03c5에 데이터를 기록하거나 혹은 0x03c5을 선도하고 레지스터 데이터를 읽어 들인다.
   * 0x03c5에 액세스 할 때 자동으로 0x03c4이 증가하고, 연속하여 다음 레지스터에 액세스 할 수있다.
   * 16bit 액세스의 경우, 액세스 후에 0x03c4에 다음의 주소 번호를 설정되는지 여부는 불명.
* [0x00] Reset (재설정)
   * bit0 : 비동기 리셋 (0 재설정)
   * bit1 : 동기화 재설정 (0으로 재설정)
   * bit2-7 : 예약
* [0x01] Clock Mode (클럭 및 모드 설정)
   * bit0 : 문자 폭 지정 (0 : 8, 1 : 9 점)
   * bit1 : 예약
   * bit2 : 16 비트 주소 지정 (1 유효)
   * bit3 : 클럭 2 분주 지정 (1 유효)
   * bit4 : 32 비트 주소 지정 (1 유효)
   * bit5 : 비 표시 설정 (1에서 사용)
* [0x02] Map Mask (일반 당 쓰기 권한)
   * bit0 : Plane0 Write Enable (1 쓰기 권한)
   * bit1 : Plane1 Write Enable (1 쓰기 권한)
   * bit2 : Plane2 Write Enable (1 쓰기 권한)
   * bit3 : Plane3 Write Enable (1 쓰기 권한)
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x03] Character Generator Select (문자 발생기 설정)
   * bit0-1 : Character Set B의 bit1-2
   * bit2-3 : Character Set A의 bit1-2
   * bit4 : Character Set B의 bit0
   * bit5 : Character Set A의 bit0
   * bit6-7 : 예약
* [0x04] Memory Mode (VRAM 모드)
   * bit0 : 예약
   * bit1 : Memory Size (0 : VRAM64KB 1 : VRAM128KB)
   * bit2 : 1,2 일반 연속 지정 (0으로 설정)
   * bit3 : 4 일반 연속 지정 (0으로 설정)
   * bit4-7 : 예약
   * 0x05 이후의 레지스터는 리저브

###비디오 DA 컨버터  
* 0x03c6 : 픽셀 마스크 레지스터 (8bit R / W)
   * bit0-7 : DA 컨버터받은 컬러 코드는이 레지스터의 내용에서 마스크 된 후 RGB로 변환되고 디스플레이에 보내진다.
* 0x03c7 : 상태 레지스터 (8bit, R)
   * bit0-1 :이 00이라면 쓰는 중
   * bit2-7 : 예약
* 0x03c7 : 주소 레지스터 (8bit, W)
   * 여기에 쓰기 액세스하면 팔레트 읽기 모드로
   * bit0-7 : 팔레트 번호
* 0x03c8 : 주소 레지스터 (8bit, W)
   * 여기에 쓰기 액세스하면 팔레트 쓰기 모드로
   * bit0-7 : 팔레트 번호
* 0x03c9 : 데이터 레지스터 (8bit R / W)
   * bit0-7 : RGB 성분의 하나 (0부터 63)
     * 쓸 때는 상위 2 비트를 0으로 가져올 때 상위 2bit를 0으로 간주
* 팔레트의 액세스 단계
   * 우선 일련의 액세스 중에 인터럽트 등이 들어 가지 않도록한다 (예를 들어 CLI).
   * 0x03c8에 설정하려는 팔레트 번호를 기입 이어 R, G, B의 순서에 0x03c9에 기록합니다. 만약 다음 팔레트도 계속 설정하고 싶다면, 팔레트 번호의 설정을 생략하고 또한 RGB 순으로 0x03c9에 기록된다.
   * 현재 팔레트 상태를 읽을 때 먼저 0x03c7 팔레트 번호를 기입 해, 0x03c9을 3 번 읽습니다. 이것이 차례로 R, G, B로되어있다. 이것도 만약 다음 팔레트도 읽고 싶을 때는, 팔레트 번호의 설정을 생략하고 RGB 순으로 판독 할 수있다.
   * 먼저 CLI 한 경우는 마지막에 STI한다.

###VGA 그래픽 컨트롤러  
* 0x03ce에 16bit 액세스 기록
   * bit0-7이 레지스터 번호
   * bit8-15 데이터
* 0x03ce과 0x03cf 바이트 액세스하는 방법도있다
   * 이 경우 우선 0x03ce 레지스터 번호를 표시하고 0x03cf에 데이터를 기록하거나 혹은 0x03cf을 선도하고 레지스터 데이터를 읽어 들인다.
* [0x00] Set / Reset (래치와의 연산에 관한 레지스터)
   * 이 레지스터는 쓰기 모드 0,3에서만 사용되는
   * bit0-3 : 컬러 코드
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x01] Enable Set / Reset (래치와의 연산에 관한 레지스터)
   * 이 레지스터는 쓰기 모드 0에서만 이용되는
   * bit0 : Plane0 Enable (1에서 enable)
   * bit1 : Plane1 Enable (1에서 enable)
   * bit2 : Plane2 Enable (1에서 enable)
   * bit3 : Plane3 Enable (1에서 enable)
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x02] Color Compare (비교 용 컬러​​ 코드)
   * 이 레지스터는 읽기 모드 1에서만 사용되는
   * bit0-3 : 컬러 코드
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x03] Data Rotate / Function Select (렌더링 된 연산과 CPU 데이터 회전 지정)
   * 쓰기 모드 0,2,3에서만 사용되는
   * bit0-2 : 오른쪽 로테이트 카운트 (0-7) CPU 데이터는 여기에 지정된 값만큼 오른쪽 로테이트 된 연산 회로에 보내진다 (000이라면 로테이트하지 않기 때문에 조금 빨라진다 여기를 사용하는 것보다 CPU로 로테이트 데이터를 쓰는 쪽이 고속이라고 알려져있다)
   * bit3-4 : 렌더링 된 연산 모드 (00 : PSET, 01 : AND, 10 : OR 11 : XOR)
   * bit5-7 : 리저브 (기입시에는 0 권장)
* [0x04] Read Plane Select (읽기 일반 선택)
   * 이 레지스터는 읽기 모드 0에서만 이용되는
   * bit0-1 : 읽기 일반 번호 (0-3)
   * bit2-7 : 리저브 (기입시에는 0 권장)
* [0x05] Mode (액세스 모드 지정)
   * bit0-1 : 쓰기 모드 번호 (0-3)
   * bit2 : 리저브 (기입시에는 0 권장)
   * bit3 : 읽기 모드 번호 (0-1)
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x06] Miscellaneous (잡일 레지스터)
   * 그릴에 직접 관계하지 않는다. 화면 모드 설정 관계. 상세 불명.
   * bit0 : Graphic Mode
   * bit1 : CGA Compatible
   * bit2-3 : VRAM Address (00 : 0xa0000~0xbffff 01 : 0xa0000~0xaffff 10 : 0xb0000~0xbffff 11 : 0xb80000~0xbffff)
   * bit4-7 : 예약
* [0x07] Color Do not Care (색상 비교 무효 일반 지정)
   * 이 레지스터는 읽기 모드 1에서만 사용되는
   * bit0 : Plane0 (1이라면이 비행기가 일치하는 것으로 간주)
   * bit1 : Plane1 (1이라면이 비행기가 일치하는 것으로 간주)
   * bit2 : Plane2 (1이라면이 비행기가 일치하는 것으로 간주)
   * bit3 : Plane3 (1이라면이 비행기가 일치하는 것으로 간주)
   * bit4-7 : 리저브 (기입시에는 0 권장)
* [0x08] Bit Mask (그리기 마스크)
   * bit0-7 : 그리기 마스크 데이터 (0 비트 렌더링되지 않음)
* 0x09 이후의 레지스터는 리저브
   * QEMU의 cirrus 모드에서는 [0x09]이 VBE 창 액세스 모드 (= 비선형 액세스)의 상위 주소 지정되어있다 (QEMU의 cirrus 모드에서는 0xa0000~0xaffff에 액세스하는 상위 주소 지정의 입도는 16KB ). 이것이 다른 카드와 어느 정도 일반화되어 있는지는 아직 알 수 없지만 만약 비교적 주요 사양이라고하면 VBE 버전이 오래 선형 액세스 모드를 지원하지 않고 BIOS를 자주 호출하지 않고 전체 VRAM에 액세스 할 수있게 될지도 모른다.

###그리기에 관련된 레지스터의 목록  
* 이렇게 레지스터가 가득 있다고 혼란 생각하기 때문에 화면 모드 설정이나 가상 화면 크기 설정 및 팔레트 설정 등에 만 사용하는 레지스터를 제외한 순수 그리기에 관련된 레지스터의 목록을 만들어 보았습니다. 각각에 대한 자세한 설명은 위 참조.
* 시퀀서보다 :
   * Map Mask 레지스터
* VGA 그래픽 컨트롤러보다 :
   * Set / Reset 레지스터
   * Enable Set / Reset 레지스터
   * Data Rotate / Function Select 레지스터
   * Mode 레지스터
   * Bit Mask 레지스터

##VRAM 주소 및 래치  
* VGA 모드의 경우 VRAM의 주소는 0xa0000에서 64KB된다. 0xb0000에서 64KB도 비디오 카드 용으로 예약되어 있지만, VGA 모드에서는 사용하지 않는다.
* 1 점이 1 비트에 대응하고 있으며, 640x480 / 8 = 37.5KB에 액세스하게된다. VGA 전시 공간은 640x480 고정이지만, 예를 들어 800x600 / 8 = 58.6KB 정도의 가상 화면을 사용할 수도있다 (또한 800x600의 표시 영역을 설정하기위한 VGA 호환 VESA 모드라는 것도 → (AT) BIOS 의 화면 모드 0x6a 참조).
* 이 설명이라고 FMR 같이 뱅크 전환 식의 일반 액세스를 상상하고 싶지되지만, 실은 그렇지 않다 (쓰기 모드 3 래치를 클리어 해두고, 또한 Map Mask 레지스터를 잘 사용하면 유사한 것 수 있습니다).
* 보통 일반 액세스라고 AND 나 OR 및 XOR을하면 액세스 한 주소 데이터와 연산을 쓸 수 있지만, VGA에서 액세스 한 주소의 데이터가 연산에 사용하지 않는다. 래치라는 일종의 레지스터가 그 레지스터와 CPU가 쓴 데이터 간의 연산을 방문한 주소에 기록된다.
   * 이것은 추측이지만 아마도 VRAM의 구조가 CPU에서의 쓰기 속도를 높이는 대신 읽기를 느리게하고, 연산마다 VRAM을 읽어 않아도되는 것처럼, 래치를 사용하도록 설계되어있다 것이다.
* 래치의 데이터와 AND 나 OR 및 XOR 연산 처리를하는 비디오 칩 속 이야기이며, CPU는 이러한 데이터를 직접 읽을 수 없다. 따라서 VRAM에 대해서는 AND 또는 OR에도 일반 MOV 명령을 사용 (VRAM에 기록). 결국 PSET의 경우와 같은 방법으로 AND 또는 OR 수 있다는 것이다. PSET / AND / OR / XOR의 지정은 Data Rotate / Function Select 레지스터의 bit3-4로 행한다.
* 래치에 데이터를 설정하려면 VRAM을 리드하면된다. 리드 부분의 VRAM의 상태가 래치로 비디오 칩에 포함된다.

##4 개의 쓰기 모드  
* 모드 0
   * 까다로운 비해서는 용도 불명.
   * Enable Set / Reset 레지스터에서 enable되어 일반에 대해서는 모드 3에서 CPU 데이터가 0xff 일 때와 같은 결과가된다 (즉이 일반에 관해서는 라이트시 CPU 데이터는 무시되었는지에 된다).
   * Enable Set / Reset 레지스터에서 disable되어 일반에 대해서는 모드 3에서 Set / Reset 레지스터가 0x0f 일 때와 같은 결과가된다 (즉이 일반에 관해서는 쓸 때의 Set / Reset 레지스터의 내용이 무시되는 것이다).
   * 이 모드가 다른 모드보다 편리하게 사용할 수있는 국면이 있으시면 꼭 가르쳐주세요.
* 모드 1
   * CPU 데이터에 관계없이 래치의 내용이 그대로 VRAM에 기록된다. Bit Mask 레지스터의 마스크조차 듣지 않는 (다운).
   * 가장 빠른 렌더링 모드.
   * VRAM이 필하려는 경우 등에 많이한다. 처음 8 점을 다른 모드로 그린다 그것을 래치에로드, 나머지는 라이트 방문하는 것만으로 필되어가는 것이다.
   * OSASK는 마우스 커서의 삭제에 사용하는 (그리기 전에 VRAM 공간에 모드 1을 사용하여 마우스 커서 위치의 VRAM 상태를 전송 (리드와 라이트를 번갈아 할거야) 삭제시 전송 방향을 반대로 한다).
* 모드 2
   * CPU가 쓴 데이터를 색상 코드로 해석 (상위 4bit는 무시된다).
   * Data Rotate / Function Select 레지스터의 기능 래치의 내용과 연산.
   * 액세스 한 주소의 8 점이 각각 같은 색상의 같은 연산을 실시하게된다.
   * Bit Mask 레지스터는 유효 마스크 된 점은 변경되지 않는다.
   * 결국 어떤 상황에서 도움이되는지 잘 모르겠다 모드.
* 모드 3
   * CPU가 쓴 데이터를 8 점의 마스크 패턴으로 해석. 1 점은 래치의 데이터와 연산되어 0 점은 래치 데이터가 그대로 사용된다.
   * Data Rotate / Function Select 레지스터의 기능 래치의 내용과 연산.
   * 연산에 사용하는 색상은 Set Reset 레지스터를 지정합니다.
   * Bit Mask 레지스터는 유효 마스크 된 점은 변경되지 않는다.
   * K 가 가장 유용하다고 생각하는 모드. OSASK에서는 글꼴 그리기 등에서 많이하고있다.
      * 래치에 배경색을 읽어 놓고 글꼴 색상 Set Reset 레지스터 세트. Bit Mask는 0xff. PSET 모드에서 글꼴 패턴을 CPU에서 VRAM에 써 주면 비교적 빠르게 글꼴이 그려있다.
      * 덧붙여서 OSASK에서는 대부분의 렌더링에있어서 쓰기 모드는 3 고정 Bit Mask는 0xff에 고정되어있다. 예를 들어 1 점만 치고 싶을 때는 Bit Mask를 변경하여 다른 7 점을 불변하는 것이 아니라 먼저 그 장소를 선도하고 래치에 포함시키고, 그래서 같은 주소에 0x80 등을 쓴다. 이 방법이 좋은 것은 색상을 변경하지 않는 한 I / O 액세스하지 않아도 좋기 때문에, 렌더링 속도가 빠른 것.
      * 이어지므로 써두면 OSASK는 VRAM 공간 (오프 스크린)의 16 바이트를 사용하여 색상 0이 8 점 늘어선 부분 컬러 1가 8 점 늘어선 부분 컬러 2가 8 점 늘어선 부분 ...을 숨겨 가지고있다. 이것은 래치를 임의의 색상으로 메우는 데 사용하고, 문자 그리기 배경색 설정, 모드 1에서 필 때 래치 초기화 용으로 이용하고있다.
      * 만약 다른 좋을 것 같은 방법이 있으면 (모드 3에 한정하지 않고) 의견에 점점 정보를 보내주십시오. 모두 빠른 알고리즘을 공유합시다.

##두 읽기 모드  
* 모드 0
   * VRAM에 읽기 액세스하면 8 점이 래치에 삽입되어 래치 중 Read Plane Select에서 선택된 일반의 내용이 그대로 CPU에 전달된다.
   * 단순 명쾌한 때문에 아마 읽기 모드 중에서는 가장 빠르게.
* 모드 1
   * VRAM에 읽기 액세스하면 8 점이 래치에 삽입되어 래치 8 점이 Color Compare 레지스터와 각각 비교하여 일치 한 비트는 1 불일치는 0으로 8 비트 집계되어 그 결과가 CPU에 전달 된다.
   * 비교시에는 Color Do not Care 레지스터도 이용된다.
   * 다소 복잡하기 때문에 리드 wait가 다목에 들어갈 가능성이있다. 그러나 이것은 이제 편리한 모드라고 생각한다.

##팔레트의 설정  
* VGA 팔레트 설정은 2 단식으로되어있다.
   * 우선 비디오 칩은 VRAM에서 색상 코드 (0 ~ 15)을 리드한다.
   * 그것을 속성 컨트롤러의 테이블에서 0부터 63 컬러 코드로 변환한다.
   * 그 0부터 63의 값은 픽셀 마스크 레지스터 (비디오 DA 컨버터)의 내용에 마스크되는 (결과 0부터 63)
   * 마스크 된 값에서 비디오 DA 컨버터 테이블에서 RGB로 변환한다.
      * 각각의 RGB 계조 수는 6bit. 즉 VGA는 26 만 색 중 16 색이라는 것이다.
   * 2 단식으로되어있는 것은, EGA와의 호환을 위해.
      * 이것은 매우 지루한 때문에 속성 컨트롤러의 테이블을 0 → 0,1 → 1,2 → 2,3 → 3, ... 15 → 15처럼 설정해 두는 것을 추천한다.
* 속성 컨트롤러에 대한 액세스 및 비디오 DA 컨버터에 대한 액세스는 시간이 지남에 말라 때문에 설정 중에 인터럽트가 들어 가지 않도록하는 것이 바람직하다.
   * 어중간한 곳에 시간이 걸릴 하드웨어 측면의 위상을 되돌아 소프트웨어 측의 위상과 불일치가 발생하여 오동작 할 것이다.
   * 속성 컨트롤러가 패닉을 일으키면 비디오 칩이 만요.

##스크롤 등  
* VRAM 구성을 실제 화면 크기보다 크게하는 방법
   * VGA는 VRAM에 여유가 있으면, VRAM의 화면 크기를 640x480 이상으로 설정 가능하며,이를 사용하여 화면을 스크롤 할 수있다.
   * 이것은 CRT 컨트롤러의 오프셋 레지스터를 사용 (0x13). 이곳은 VRAM의 x 방향의 화면 크기를 설정하는 곳에, 단어 수준, 즉 16 점 단위로 지정한다.
   * 예를 들어 640 점이라면 0x28,800 점이라면 0x32된다.
* 스크롤
   * 우선, CRT 컨트롤러의 레지스터 [0x0c 및 0x0d를 사용하면 x 방향 8 점 단위, y 방향 1 점 단위의 스크롤있다.
   * 만약 x 방향으로 1 도트 단위의 스크롤이 원한다면 8로 나눈 나머지를 속성 컨트롤러의 레지스터 [0x13로 설정한다.

##BIOS를 사용하지 VGA 모드려면  
* 전제 : 전환 이전 화면 모드는 VGA 혹은 그 이전 규격 (MDA, CGA, EGA, MCGA) 시대의 화면 모드가 아닌 말라 (BIOS 화면 모드로 말하면 0x00~0x07과 0x0d~0x13의 중 하나). 이것을 채우지 않는 화면 모드 (VESA 확장 된 화면 모드 등)는 VGA 레지스터의 예약 부분에서 VGA 호환에 설정되어있는 경우가 많으며, VGA에서 정의 된 레지스터를 만지고도 VGA 화면 가되지 않는다.
* 또한 이 방법으로 화면을 전환 한 후에는 BIOS 및 VESA 기능으로 화면을 전환 할 대부분은 수 없게된다. 라고하는 것은, BIOS 및 VESA는 현재 화면 모드를 내부에 기억하고 화면 모드 전환시 변화하는 레지스터만을 설정하는 것이 많아 이렇게 자기 부담으로 만져 버리면 차이가 발생て BIOS 및 VESA 혼란 전환이 잘 할 수 없기 때문이다.
   * 그러나 여기에서는 처음처럼 BIOS를 사용하고 싶지 않다 든가, 또한 VESA도 사용하고 싶지 않거나 사용할 수없는 상황을 상정 한 이야기​​이므로,이 제약이되지 않을 것이다.
* 또한 BIOS 및 VESA 화면 모드를 전환해도 예를 들어 팔레트를 자기 부담 I / O 액세스 만지고, VRAM에 1 라인 당 바이트 수 등을 만지는 것은 다음의 BIOS를 통해, VESA 통해 화면 모드 설정에는 영향을주지 않도록한다. 그래서 여기에서의 설정 예를 참고로하면서 위 레지스터 군의 의미를 이해하고 활용하는 것도 좋을 것이다.
* 구체적인 설정 예
   * 다음 적절하게 인터럽트 금지 등을하여 타이밍을 미치지 않도록 할
   * 시퀀서 [0x00]에 0x01 쓰기 (DX = 0x03c4; AX = 0x0100; OUT (DX, AX);)
   * VGA 컨트롤러 설정
      * 컨트롤 레지스터에 0xe3 쓰기 (DX = 0x03c2; AL = 0xe3; OUT (DX, AL);)
      * VGA 동작 허가 레지스터에 0x01 쓰기 (DX = 0x03c3; AL = 0x01; OUT (DX, AL);)
   * 시퀀서 설정
      * 레지스터 [0x01] ~ [0x04]에 {0x01, 0x0f, 0x00, 0x06} 쓰기
      * 그 후에 레지스터 [0x00]에 0x03 쓰기
   * CRT 컨트롤러 설정
      * 레지스터 [0x11]에 0x20 쓰기
      * 레지스터 [0x00] ~ [0x07]에 {0x5f, 0x4f, 0x50, 0x82, 0x54, 0x80, 0x0b, 0x3e} 쓰기
      * 레지스터 [0x08] ~ [0x0f]에 {0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} 쓰기
      * 레지스터 [0x10] ~ [0x18]에 {0xea, 0x8c, 0xdf, 0x28, 0x00, 0xe7, 0x04, 0xe3, 0xff} 쓰기
   * VGA 그래픽 컨트롤러 설정
      * 여기의 설정은 자신이 먼저 사용 모드 등에 따라 설정된다. 여기에서는 [0x06]의 설정이 주된 목적.
      * 레지스터 [0x00] ~ [0x08]에 {0x00, 0x0f, 0x00, 0x00, 0x00, 0x03, 0x05, 0x00, 0xff} 쓰기
   * 속성 컨트롤러 설정
      * 0x03da 더미 리드 등을 잊지 않고
      * 레지스터 [0x00] ~ [0x07]에 {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07} 쓰기
      * 레지스터 [0x08] ~ [0x0f]에 {0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f} 쓰기
      * 레지스터 [0x10] ~ [0x14]에 {0x01, 0x00, 0x0f, 0x00, 0x00} 쓰기
      * 0x03da 더미 리드와 0x20 쓰기를 잊지 않고
   * 비디오 DA 컨버터 픽셀 마스크에 0xff 쓰기 (DX = 0x03c6; AL = 0xff; OUT (DX, AL);)
   * 다음은 비디오 DA 컨버터 팔레트 0x00~0x0f을 취향에 맞게 설정

1차 출처: [http://web.archive.org/web/20100915170717/http://community.osdev.info/?VGA#navigator](http://web.archive.org/web/20100915170717/http://community.osdev.info/?VGA#navigator)
(http://community.osdev.info/?VGA#navigator)
